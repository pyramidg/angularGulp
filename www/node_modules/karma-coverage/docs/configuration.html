<h1>Configuration</h1><h3><code>type</code></h3><p><strong>Type:</strong> String</p>
<p><strong>Description:</strong> Specify a reporter type.</p>
<p><strong>Possible Values:</strong></p>
<ul>
<li><code>html</code> (default)</li>
<li><code>lcov</code> (lcov and html)</li>
<li><code>lcovonly</code></li>
<li><code>text</code></li>
<li><code>text-summary</code></li>
<li><code>cobertura</code> (xml format supported by Jenkins)</li>
<li><code>teamcity</code> (code coverage System Messages for TeamCity)</li>
<li><code>json</code> (json format supported by <a href="https://github.com/daniellmb/grunt-istanbul-coverage"><code>grunt-istanbul-coverage</code></a>)</li>
<li><code>in-memory</code> (supported since v0.5.4)</li>
</ul>
<h3><code>dir</code></h3><p><strong>Type:</strong> String</p>
<p><strong>Description:</strong> This will be used to output coverage reports. When
  you set a relative path, the directory is resolved against the <code>basePath</code>.</p>
<h3><code>subdir</code></h3><p><strong>Type:</strong> String</p>
<p><strong>Description</strong>: This will be used in complement of the <code>coverageReporter.dir</code>
option to generate the full output directory path. By default, the output
directory is set to <code>./config.dir/BROWSER_NAME/</code>, this option allows you to
custom the second part. You can either pass a <code>string</code> or a <code>function</code> which will be
called with the browser name passed as the only argument.</p>
<pre><code class="language-javascript">coverageReporter: {
  dir: &#39;coverage&#39;,
  subdir: &#39;.&#39;
  // Would output the results into: .&#39;/coverage/&#39;
}
</code></pre>
<pre><code class="language-javascript">coverageReporter: {
  dir: &#39;coverage&#39;,
  subdir: &#39;report&#39;
  // Would output the results into: .&#39;/coverage/report/&#39;
}
</code></pre>
<pre><code class="language-javascript">coverageReporter: {
  dir: &#39;coverage&#39;,
  subdir: function(browser) {
    // normalization process to keep a consistent browser name across different
    // OS
    return browser.toLowerCase().split(/[ /-]/)[0];
  }
  // Would output the results into: &#39;./coverage/firefox/&#39;
}
</code></pre>
<h3><code>file</code></h3><p><strong>Type:</strong> String</p>
<p><strong>Description:</strong> If you use one of these reporters, <code>cobertura</code>, <code>lcovonly</code>, <code>teamcity</code>, <code>text</code> or <code>text-summary</code>,you may set the <code>file</code> option to specify the output file.</p>
<pre><code class="language-javascript">coverageReporter: {
  type : &#39;text&#39;,
  dir : &#39;coverage/&#39;,
  file : &#39;coverage.txt&#39;
}
</code></pre>
<h3><code>check</code></h3><p><strong>Type:</strong> Object</p>
<p><strong>Description:</strong> This will be used to configure minimum threshold enforcement for coverage results. If the thresholds are not met, karma will return failure. Thresholds, when specified as a positive number are taken to be the minimum percentage required. When a threshold is specified as a negative number it represents the maximum number of uncovered entities allowed.</p>
<p>For example, <code>statements: 90</code> implies minimum statement coverage is 90%. <code>statements: -10</code> implies that no more than 10 uncovered statements are allowed.</p>
<p><code>global</code> applies to all files together and <code>each</code> on a per-file basis. A list of files or patterns can be excluded from enforcement via the <code>exclude</code> property. On a per-file or pattern basis, per-file thresholds can be overridden via the <code>overrides</code> property.</p>
<pre><code class="language-javascript">coverageReporter: {
  check: {
    global: {
      statements: 50,
      branches: 50,
      functions: 50,
      lines: 50,
      excludes: [
        &#39;foo/bar/**/*.js&#39;
      ]
    },
    each: {
      statements: 50,
      branches: 50,
      functions: 50,
      lines: 50,
      excludes: [
        &#39;other/directory/**/*.js&#39;
      ],
      overrides: {
        &#39;baz/component/**/*.js&#39;: {
          statements: 98
        }
      }
    }
  }
}
</code></pre>
<h3><code>watermarks</code></h3><p><strong>Type:</strong> Object</p>
<p><strong>Description:</strong> This will be used to set the coverage threshold colors. The first number is the threshold between Red and Yellow. The second number is the threshold between Yellow and Green.</p>
<pre><code class="language-javascript">coverageReporter: {
  watermarks: {
    statements: [ 50, 75 ],
    functions: [ 50, 75 ],
    branches: [ 50, 75 ],
    lines: [ 50, 75 ]
  }
}
</code></pre>
<h3><code>includeAllSources</code></h3><p><strong>Type:</strong> Boolean</p>
<p><strong>Description:</strong> You can opt to include all sources files, as indicated by the coverage preprocessor, in your code coverage data, even if there are no tests covering them. (Default <code>false</code>)</p>
<pre><code class="language-javascript">coverageReporter: {
  type : &#39;text&#39;,
  dir : &#39;coverage/&#39;,
  file : &#39;coverage.txt&#39;,
  includeAllSources: true
}
</code></pre>
<h3><code>sourceStore</code></h3><p><strong>Type:</strong> istanbul.Store</p>
<p><strong>Description:</strong> You can opt to specify a source store allowing for external coverage collectors access to the instrumented code.</p>
<pre><code class="language-javascript">coverageReporter: {
  type : &#39;text&#39;,
  dir : &#39;coverage/&#39;,
  file : &#39;coverage.txt&#39;,
  sourceStore : require(&#39;istanbul&#39;).Store.create(&#39;fslookup&#39;)
}
</code></pre>
<h3><code>reporters</code></h3><p><strong>Type:</strong> Array of Objects</p>
<p><strong>Description:</strong> You can use multiple reporters, by providing array of options.</p>
<pre><code class="language-javascript">coverageReporter: {
  reporters:[
    {type: &#39;html&#39;, dir:&#39;coverage/&#39;},
    {type: &#39;teamcity&#39;},
    {type: &#39;text-summary&#39;}
  ],
}
</code></pre>
<h3><code>instrumenter</code></h3><p><strong>Type:</strong> Object</p>
<p><strong>Description:</strong> Karma-coverage can infers the instrumenter regarding of the file extension. It is possible to override this behavior and point out an
instrumenter for the files matching a specific pattern.
To do so, you need to declare an object under with the keys represents the
pattern to match, and the instrumenter to apply. The matching will be done
using <a href="https://github.com/isaacs/minimatch">minimatch</a>.
If two patterns match, the last one will take the precedence.</p>
<p>For example you can use <a href="https://github.com/Constellation/ibrik">Ibrik</a> (an
<a href="https://github.com/gotwarlost/istanbul">Istanbul</a> analog for
CoffeeScript files) with:</p>
<pre><code class="language-javascript">coverageReporter: {
  instrumenters: { ibrik : require(&#39;ibrik&#39;) },
  instrumenter: {
    &#39;**/*.coffee&#39;: &#39;ibrik&#39;
  },
  // ...
}
</code></pre>
<p>You can pass options additional options to specific instrumenter with:</p>
<pre><code class="language-javascript">var to5Options = { experimental: true };

// [...]

coverageReporter: {
  instrumenters: { isparta : require(&#39;isparta&#39;) },
  instrumenter: {
    &#39;**/*.js&#39;: &#39;isparta&#39;
  },
  instrumenterOptions: {
    isparta: { to5 : to5Options }
  }
}
</code></pre>
<h3><code>useJSExtensionForCoffeeScript</code></h3><p><strong>Type:</strong> boolean</p>
<p><strong>Description:</strong> If set to <code>true</code>, then CoffeeScript files instrumented
with <a href="https://github.com/Constellation/ibrik">Ibrik</a> will use the <code>.js</code>
extension for the transpiled source (without this option, the JavaScript
files will keep the original <code>.coffee</code> extension). This option is required
if you use a module loader such as <a href="http://requirejs.org/">RequireJS</a> that
expects files to use a <code>.js</code> extension.</p>
<p>Example of using RequireJS with CoffeeScript:</p>
<pre><code class="language-coffeescript">coverageReporter:
  useJSExtensionForCoffeeScript: true
  instrumenters:
    ibrik : require(&#39;ibrik&#39;)
  instrumenter:
    &#39;**/*.coffee&#39;: &#39;ibrik&#39;
# ...
</code></pre>
<h3><code>reporter[type=&#39;in-memory&#39;]</code></h3><p>This is a different kind of reporter. Instead of writing a report physicaly 
to disk, it raises an event <code>coverage_complete</code>. This event can only be caught 
when using karma via the <a href="http://karma-runner.github.io/0.13/dev/public-api.html">public api</a></p>
<pre><code class="language-javascript">var Server = require(&#39;karma&#39;).Server
var server = new Server({files: [/*...*/], port: 9876, coverageReporter: { type: &#39;in-memory&#39; }, preprocessors: { &#39;**/*.js&#39;: &#39;coverage&#39; }, reporters: [&#39;coverage&#39;] }, function(exitCode) {
  console.log(&#39;Karma has exited with &#39; + exitCode)
  process.exit(exitCode)
})

server.on(&#39;coverage_complete&#39;, function (browser, coverageReport) {
  console.log(&#39;Covrage report: &#39;, coverageReport)
})

server.start();

karma.runner.run({port: 9876});
</code></pre>
<p>The coverage report will be a merged result in json format.</p>
